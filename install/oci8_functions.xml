<?xml version='1.0' encoding='UTF-8' ?>
<!--
/**
* +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
* | Squiz.net Open Source Licence                                      |
* +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
*
* $Id: oci8_functions.xml,v 1.7 2005/11/17 04:15:12 mmcintyre Exp $
*
*/
-->
<sql>
	<sql_element display_name="Varchar 500 Table Type">
		<![CDATA[
			CREATE OR REPLACE TYPE VARCHAR_500_TABLE is TABLE OF VARCHAR2(500);
		]]>
	</sql_element>
	<sql_element display_name="Varchar 2000 Table Type">
		<![CDATA[
			CREATE OR REPLACE TYPE VARCHAR_2000_TABLE is TABLE OF VARCHAR2(2000);
		]]>
	</sql_element>
	<sql_element display_name="common_pkg Package">
		<![CDATA[
			CREATE OR REPLACE PACKAGE sq_common_pkg AS
				PROCEDURE sq_set_rollback_timestamp(in_date IN DATE := NULL);
				FUNCTION sq_get_rollback_timestamp RETURN DATE;
			END sq_common_pkg;
		]]>
	</sql_element>
	<sql_element display_name="common_pkg Package Body">
		<![CDATA[
			CREATE OR REPLACE PACKAGE BODY sq_common_pkg AS

				v_date DATE;

				PROCEDURE sq_set_rollback_timestamp(in_date IN DATE := NULL) IS
				BEGIN
					IF in_date IS NULL THEN
						SELECT sysdate INTO v_date FROM dual;
					ELSE
						v_date := in_date;
					END IF;
				END;

				FUNCTION sq_get_rollback_timestamp RETURN DATE IS
				BEGIN
						RETURN v_date;
				END;
			END sq_common_pkg;
		]]>
	</sql_element>
	<sql_element display_name="sq_get_lineage_from_url Function">
		<![CDATA[
			-- returns all the urls up to the specified url so that we can use an IN
			-- clause rather than a LIKE clause for a better query plan
			CREATE OR REPLACE FUNCTION sq_get_lineage_from_url(url IN VARCHAR2) RETURN VARCHAR_500_TABLE IS
				-- urls can only be 500 chars long
				next_url VARCHAR2(500);
				concat_url VARCHAR2(500);
				i INTEGER;
				next_slash INTEGER;
				pos INTEGER;
				urls VARCHAR_500_TABLE := VARCHAR_500_TABLE();
			BEGIN
				i := 1;
				next_slash := 1;
				pos := 1;
				concat_url := NULL;

				LOOP
					pos := instr(url, '/', 1, next_slash);

					IF pos = 0 THEN
						-- if pos is 0 then get the component to the end of the url
						next_url := substr(url, i, length(url));
					ELSE
						next_url := substr(url, i, (pos - i));
					END IF;

					IF concat_url IS NOT NULL THEN
						concat_url := concat_url || '/';
					END IF;
					concat_url := concat_url || next_url;
					urls.extend;
					urls(urls.count) := concat_url;

					IF pos = 0 THEN
						-- we have the last url so we are done
						return urls;
					END IF;

					i := pos + 1;
					next_slash := next_slash + 1;

				END LOOP;
				RETURN urls;

			END sq_get_lineage_from_url;
		]]>
	</sql_element>
	<sql_element display_name="sq_get_parent_treeids Function">
		<![CDATA[
			-- returns the parent treeids for the specified assetid
			-- if timestamp is null then the function will assume that we are not in rollback mode
			-- if the timestamp is valid the function will return the treeids from the rollback tables
			CREATE OR REPLACE FUNCTION sq_get_parent_treeids(minorid IN VARCHAR2, SQ_TREE_BASE_SIZE IN INTEGER , rb_date IN DATE := NULL) RETURN VARCHAR_2000_TABLE IS
				offset int;
				next_treeid VARCHAR2(2000);
				db_treeid VARCHAR2(2000);
				parent_treeids VARCHAR_2000_TABLE := VARCHAR_2000_TABLE();
				concat_treeids VARCHAR2(2000);
				table_prefix VARCHAR2(6);
				sql_str VARCHAR2(2000);
				cursor_ptr INTEGER;
				ignore INTEGER;
			BEGIN
				IF rb_date IS NULL THEN
					table_prefix := 'sq_';
				ELSE
					table_prefix := 'sq_rb_';
				END IF;

				sql_str := 'SELECT treeid FROM ' || table_prefix || 'ast_lnk l INNER JOIN ' || table_prefix || 'ast_lnk_tree t ON l.linkid = t.linkid
						WHERE l.minorid = ' || minorid;

				IF rb_date IS NOT NULL THEN
					sql_str := sql_str || ' AND l.sq_eff_from <= TO_DATE("' || rb_date || '", "YYYY-MM-DD HH24:MI:SS")'
						|| ' AND (l.sq_eff_to IS NULL OR l.sq_eff_to > TO_DATE("' || rb_date || '", "YYYY-MM-DD HH24:MI:SS")' || ')';

					sql_str := sql_str || ' AND t.sq_eff_from <= TO_DATE("' || rb_date || '", "YYYY-MM-DD HH24:MI:SS")'
						|| ' AND (t.sq_eff_to IS NULL OR t.sq_eff_to > TO_DATE("' || rb_date || '", "YYYY-MM-DD HH24:MI:SS")' || ')';

					sql_str := replace(sql_str, '"', '''' );
				END IF;

				cursor_ptr := DBMS_SQL.open_cursor;
				DBMS_SQL.PARSE(cursor_ptr, sql_str, DBMS_SQL.V7);
				DBMS_SQL.DEFINE_COLUMN(cursor_ptr, 1, db_treeid, 500);
				ignore := DBMS_SQL.EXECUTE(cursor_ptr);

				LOOP
					IF DBMS_SQL.FETCH_ROWS(cursor_ptr) > 0 THEN
						DBMS_SQL.COLUMN_VALUE(cursor_ptr, 1, db_treeid);
						offset := 1;
						concat_treeids := '';
						LOOP
							next_treeid := SUBSTR(db_treeid, offset, SQ_TREE_BASE_SIZE);
							EXIT WHEN next_treeid IS NULL;
							concat_treeids := concat_treeids || next_treeid;
							parent_treeids.extend;
							parent_treeids(parent_treeids.count) := concat_treeids;
							offset := offset + SQ_TREE_BASE_SIZE;
						END LOOP;
					ELSE
						EXIT;
					END IF;
				END LOOP;

				DBMS_SQL.CLOSE_CURSOR(cursor_ptr);
				RETURN parent_treeids;
			END sq_get_parent_treeids;
		]]>
	</sql_element>
	<sql_element display_name="sq_rb_get_parent_treeids Function">
		<![CDATA[
			-- returns the parent treeids for the specified assetid using the date
			-- acquired from the sq_get_rollback_timestamp function
			CREATE OR REPLACE FUNCTION sq_rb_get_parent_treeids(minorid IN VARCHAR2, SQ_TREE_BASE_SIZE IN INTEGER) RETURN VARCHAR_2000_TABLE IS
				rb_date DATE;
			BEGIN
				rb_date := sq_common_pkg.sq_get_rollback_timestamp();
				RETURN sq_get_parent_treeids(minorid, SQ_TREE_BASE_SIZE, rb_date);
			END sq_rb_get_parent_treeids;
		]]>
	</sql_element>
	<sql_element display_name="asset_link_treeid_convert Function">
		<![CDATA[
		CREATE OR REPLACE FUNCTION asset_link_treeid_convert(value IN VARCHAR2, encode IN CHAR, TREE_BASE IN INTEGER, TREE_SIZE IN INTEGER) RETURN VARCHAR2 IS
			str VARCHAR2(2000);
			pad_str VARCHAR2(2000);
			i INTEGER   := 0;
			x INTEGER   := 0;
			d INTEGER   := 0;
			num INTEGER := 0;
			pos INTEGER := 0;
			DIGITS CONSTANT CHAR(64) := '0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~';
		BEGIN
			IF encode = '1' THEN

				i := CAST(value AS INTEGER);
				WHILE i != 0 LOOP
					pos := MOD(i, TREE_BASE);
					str := SUBSTR(DIGITS, pos + 1, 1) || str;
					i := FLOOR(i / TREE_BASE);
				END LOOP;
				IF LENGTH(str) > TREE_SIZE THEN
					RAISE_APPLICATION_ERROR(-20001, 'Broken! value: ' || value || ' str: ' || str || ' TREE_SIZE : ' || TREE_SIZE);
					RETURN NULL;
				ELSE
					IF str IS NULL THEN
						pos := TREE_SIZE;
					ELSE
						pos := (TREE_SIZE - LENGTH(str));
					END IF;
					FOR i IN 1..pos LOOP
						pad_str := pad_str || SUBSTR(DIGITS, 0, 1);
					END LOOP;
					RETURN pad_str || str;
				END IF;
			ELSE
				num := 0;
				x := POWER(TREE_BASE, LENGTH(value) - 1);
				FOR i IN 1..LENGTH(value) LOOP
					d := INSTR(DIGITS, SUBSTR(value, i, 1));
					IF d = 0 THEN
						RETURN NULL;
					END IF;
					-- -1 from d as instr starts at 1 not 0
					d := d - 1;
					num := num + (x * d);
					x := x / TREE_BASE;
				END LOOP;
				RETURN num;
			END IF;
		END asset_link_treeid_convert;
		]]>
	</sql_element>
	<sql_element display_name="get_next_treeid Function">
		<![CDATA[
			CREATE OR REPLACE FUNCTION get_next_treeid(existing_treeid IN VARCHAR2, majorid IN VARCHAR2, TREE_BASE IN INTEGER, TREE_SIZE IN INTEGER) RETURN VARCHAR2 IS
				free_childid VARCHAR2(2000);
				sql_str VARCHAR2(2000);
				child_num INTEGER;
			BEGIN
				BEGIN
					-- try to find any entries in the link tree under parent that are free
					EXECUTE IMMEDIATE 'SELECT treeid FROM(SELECT SUBSTR(ct.treeid, (LENGTH(ct.treeid) + 1) - ' || TREE_SIZE || ') treeid,
						  RANK() OVER (ORDER BY treeid DESC) highest
						  FROM sq_ast_lnk_tree ct
						  WHERE ct.treeid LIKE ''' || existing_treeid || '%''
						  AND ct.treeid > ''' || existing_treeid || '''
						  AND LENGTH(ct.treeid) = ' || (LENGTH(existing_treeid) + TREE_SIZE) || '
						  AND ct.linkid = 0) WHERE highest = 1' INTO free_childid;

					-- if there was no exception then we can free up this entry and return it
					EXECUTE IMMEDIATE 'DELETE FROM
											sq_ast_lnk_tree
										WHERE
											treeid IN
											(
												SELECT
													t.treeid || ''' || free_childid || '''
												FROM
													ast_lnk_tree t
												INNER JOIN
													ast_lnk l ON t.linkid = l.linkid
												WHERE
													l.minorid = ''' || majorid || '''
											)';
					RETURN free_childid;
				EXCEPTION
					WHEN NO_DATA_FOUND THEN
						BEGIN
							sql_str := 'SELECT treeid FROM(SELECT SUBSTR(ct.treeid, (LENGTH(ct.treeid) + 1) - ' || TREE_SIZE || ') treeid,
										RANK() OVER (ORDER BY treeid DESC) highest
										FROM
									   sq_ast_lnk_tree ct';
								-- if we are not the root folder, the we need to get the correct treeid length
								IF (existing_treeid != '-') THEN
									sql_str := sql_str || ' WHERE ct.treeid LIKE ''' || existing_treeid || '%''
										AND ct.treeid > ''' || existing_treeid || '''
										AND LENGTH(ct.treeid) = ' || (LENGTH(existing_treeid) + TREE_SIZE);
								ELSE
									sql_str := sql_str || ' WHERE LENGTH(ct.treeid) = ' || TREE_SIZE;
								END IF;
								sql_str := sql_str || ') WHERE highest = 1';
								EXECUTE IMMEDIATE sql_str INTO free_childid;

								-- we found a max so increment it
								child_num    := CAST(asset_link_treeid_convert(free_childid, '0', TREE_BASE, TREE_SIZE) AS INTEGER);
								free_childid := asset_link_treeid_convert(child_num + 1, '1', TREE_BASE, TREE_SIZE);
								RETURN free_childid;
						EXCEPTION
							-- no max, we must be the first
							WHEN NO_DATA_FOUND THEN
								free_childid := asset_link_treeid_convert('0', '1', TREE_BASE, TREE_SIZE);
								return free_childid;
						END;
				END;
			END get_next_treeid;
		]]>
	</sql_element>
</sql>
