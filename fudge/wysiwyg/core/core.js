// This code is not generated by the script and is not affected by
// any plugins of HTMLArea. Thus, it has been placed in a seperate
// include file for caching


/** Helper function: replace all TEXTAREA-s in the document with HTMLArea-s. */
HTMLArea.replaceAll = function() {
	var tas = document.getElementsByTagName("textarea");
	for (var i = tas.length; i > 0; (new HTMLArea(tas[--i])).generate());
};


// Creates the HTMLArea object and replaces the textarea with it.
HTMLArea.prototype.generate = function () {
	var editor = this; // we'll need "this" in some nested functions
	// get the textarea
	var textarea = this._textArea;
	if (typeof textarea == "string") {
		// it's not element but ID
		this._textArea = textarea = document.getElementById(textarea);
	}
	this._ta_size = {
		w: textarea.offsetWidth,
		h: textarea.offsetHeight
	};

	// hide the textarea
	textarea.style.display = "none";

	// create the editor framework
	var htmlarea = document.createElement("div");
	htmlarea.className = "htmlarea";
	this._htmlArea = htmlarea;

	// insert the editor before the textarea.
	textarea.parentNode.insertBefore(htmlarea, textarea);

	// retrieve the HTML on submit
	HTMLArea._addEvent(textarea.form, "submit", function (event) {
		editor._formSubmit(HTMLArea.is_ie ? window.event : event);
	});

	// creates & appends the toolbar
	//this._createToolbar();
	this._htmlArea.appendChild(this._toolbar);

	if (HTMLArea.is_gecko || editor.config.bodyType.toLowerCase() == 'iframe') {
		// create the IFRAME
		var iframe = document.createElement("iframe");
		htmlarea.appendChild(iframe);
		this._iframe = iframe;

		// resize the iframe after the window is loaded
		HTMLArea._addEvent(window, "load", function (event) {
			editor._resizeIframe(HTMLArea.is_ie ? window.event : event);
		});
	} else if (HTMLArea.is_ie && editor.config.bodyType.toLowerCase() == 'div') {
		var contentDiv = document.createElement("div");
		this._htmlArea.appendChild(contentDiv);
		this._doc = contentDiv;
	}

	// IMPORTANT: we have to allow Mozilla a short time to recognize the
	// new frame. Otherwise we get a stupid exception.
	function initIframe() {
		var doc = editor._iframe.contentWindow.document;
		if (!doc) {
			if (HTMLArea.is_gecko) {
				setTimeout(function () { editor._initIframe(); }, 10);
				return false;
			} else {
				alert("ERROR: IFRAME can't be initialized.");
			}
		}
		if (HTMLArea.is_gecko) {
			// enable editable mode for Mozilla
			doc.designMode = "on";
		}
		editor._doc = doc;
		doc.open();
		var html = "<html>\n";
		html += "<head>\n";
		if (editor.config.styleSheet) { html += "<link rel=\"stylesheet\" href=\"" + editor.config.styleSheet + "\" type=\"text/css\">"; }
		html += "<style> body { " + editor.config.bodyStyle + " } </style>\n";
		html += "</head>\n";
		html += "<body>\n";
		html += editor._textArea.value;
		html += "</body>\n";
		html += "</html>";
		doc.write(html);
		doc.close();
		editor._docContent = doc.body;

		if (HTMLArea.is_ie) {
			// enable editable mode for IE.  For some reason this doesn't 
			// work if done in the same place as for Gecko (above).
			doc.body.contentEditable = true;
		}

		editor.focusEditor();
		// intercept some events; for updating the toolbar & keyboard handlers
		HTMLArea._addEvents
			(doc, ["keydown", "keypress", "mousedown", "mouseup", "drag"],
			 function (event) {
				 return editor._editorEvent(HTMLArea.is_ie ? editor._iframe.contentWindow.event : event);
			 });
		editor.updateToolbar();
		editor.focusEditor();
		editor._initialised = true;
	};

	function initDiv() {
		editor._doc.innerHTML = editor._textArea.value;
		editor._doc.style.width  = "100%";
		editor._doc.style.height = "100%";
		//if (HTMLArea.is_gecko) { editor._doc.designMode = "on"; }
		editor._doc.innerHTML = editor._textArea.value;
		if (HTMLArea.is_ie) { editor._doc.contentEditable = true; }
		// intercept some events; for updating the toolbar & keyboard handlers
		HTMLArea._addEvents
			(editor._doc, ["keydown", "keypress", "mousedown", "mouseup", "drag"],
			 function (event) {
				 return editor._editorEvent(event);
			 });
		editor._docContent = contentDiv;
		editor._doc = editor._docContent.document;
		editor.updateToolbar();
		editor.focusEditor();
		editor._initialised = true;
	};

	if (HTMLArea.is_gecko || editor.config.bodyType.toLowerCase() == 'iframe') {
		setTimeout(initIframe, HTMLArea.is_gecko ? 10 : 0);
	} else if (HTMLArea.is_ie && editor.config.bodyType.toLowerCase() == 'div') {
		setTimeout(initDiv, 0);
	}
};


// Switches editor mode; parameter can be "textmode" or "wysiwyg"
HTMLArea.prototype.setMode = function(mode, noFocus) {
	if (this._mode == mode) return false;
	switch (mode) {
		case "textmode":
			var html = this.getHTML();
			if (HTMLArea.is_gecko) {
				var html = document.createTextNode(html);
				this._iframe.contentWindow.document.body.innerHTML = "";
				this._iframe.contentWindow.document.body.appendChild(html);
			} else if (HTMLArea.is_ie) {
				this._docContent.innerText = html;
			}
		break;
		case "wysiwyg":
			var html = this.getHTML();
			if (HTMLArea.is_gecko) {
				this._iframe.contentWindow.document.body.innerHTML = html;
			} else if (HTMLArea.is_ie) {
				this._docContent.innerHTML = html;
			}
		break;
		default:
			alert("Mode <" + mode + "> not defined!");
		return false;
	}
	this._mode = mode;
	if (!noFocus) { this.focusEditor(); }
};


// focuses the iframe window.  returns a reference to the editor document.
HTMLArea.prototype.focusEditor = function() {
	if (HTMLArea.is_gecko) {
		this._iframe.contentWindow.focus();
	} else if (HTMLArea.is_ie) {
		this._doc.focus();
	}
	return this._docContent;
};


/** 
 * Returns a node after which we can insert other nodes, in the current
 * selection.  The selection is removed.  It splits a text node, if needed.
 */
HTMLArea.prototype.insertNodeAtSelection = function(toBeInserted) {
	if (!HTMLArea.is_ie) {
		var sel = this._getSelection();
		var range = this._createRange(sel);
		// remove the current selection
		//sel.removeAllRanges();
		range.deleteContents();
		var node = range.startContainer;
		var pos = range.startOffset;
		range = this._createRange();
		switch (node.nodeType) {
			case 3: // Node.TEXT_NODE
				// we have to split it at the caret position.
				if (toBeInserted.nodeType == 3) {
					// do optimized insertion
					node.insertData(pos, toBeInserted.data);
					range.setEnd(node, pos + toBeInserted.length);
					range.setStart(node, pos + toBeInserted.length);
				} else {
					node = node.splitText(pos);
					node.parentNode.insertBefore(toBeInserted, node);
					range.setStart(node, 0);
					range.setEnd(node, 0);
				}
			break;
			case 1: // Node.ELEMENT_NODE
				if (node.childNodes[pos]) { node = node.childNodes[pos]; }
				node.parentNode.insertBefore(toBeInserted, node);
				range.setStart(node, 0);
				range.setEnd(node, 0);
			break;
		}
		sel.addRange(range);
	} else {
		return null; // this function not yet used for IE <FIXME>
	}
};


/**
 * Call this function to insert HTML code at the current position.  It deletes
 * the selection, if any.
 */
HTMLArea.prototype.insertHTML = function(html) {
	var sel = this._getSelection();
	var range = this._createRange(sel);
	if (HTMLArea.is_ie) {
		range.pasteHTML(html);
	} else {
		// construct a new document fragment with the given HTML
		var fragment = this._doc.createDocumentFragment();
		var div = this._doc.createElement("div");
		div.innerHTML = html;
		while (div.firstChild) {
			// the following call also removes the node from div
			fragment.appendChild(div.firstChild);
		}
		// this also removes the selection
		var node = this.insertNodeAtSelection(fragment);
	}
};


// completely change the HTML inside
HTMLArea.prototype.setHTML = function(html) {
	switch (this._mode) {
		case "textmode":
			if (HTMLArea.is_gecko) {
				var html = document.createTextNode(html);
				this._iframe.contentWindow.document.body.innerHTML = "";
				this._iframe.contentWindow.document.body.appendChild(html);
			} else if (HTMLArea.is_ie) {
				this._docContent.innerText = html;
			}
		break;
		case "wysiwyg":
			if (HTMLArea.is_gecko) {
				this._iframe.contentWindow.document.body.innerHTML = html;
			} else if (HTMLArea.is_ie) {
				this._docContent.innerHTML = html;
			}
		break;
		default:
			alert("Mode <" + mode + "> not defined!");
	}
	return false;
};


/**
 *  Call this function to surround the existing HTML code in the selection with
 *  your tags.
 */
HTMLArea.prototype.surroundHTML = function(startTag, endTag) {
	var html = this.getSelectedHTML();
	// the following also deletes the selection
	this.insertHTML(startTag + html + endTag);
};


// Retrieve the selected block
HTMLArea.prototype.getSelectedHTML = function() {
	var sel = this._getSelection();
	var range = this._createRange(sel);
	var existing = null;
	if (HTMLArea.is_ie) {
		existing = range.htmlText;
	} else {
		existing = HTMLArea.getHTML(range.cloneContents(), false);
	}
	return existing;
};


// gets called before the form is submitted
HTMLArea.prototype._formSubmit = function(ev) {
	// retrieve the HTML
	this._textArea.value = this.getHTML();
};


// resize the iframe
HTMLArea.prototype._resizeIframe = function(ev) {
	// This function creates a new textarea of the
	// same width and height as the original, but appends
	// it to the body of the document.
	if (this.config.width != "auto" && this.config.height != "auto") {
		this._iframe.style.width = this.config.width;
		this._iframe.style.height = this.config.height;
		return;
	}

	var textarea = document.createElement("textarea");
	document.body.appendChild(textarea);
	
	// grab the attributes that determine size
	textarea.style.width = this._textArea.style.width;
	textarea.style.height = this._textArea.style.height;
	textarea.rows = this._textArea.rows;
	textarea.cols = this._textArea.cols;
	textarea.className = this._textArea.className;

	// get the width and height of the text area
	var width = textarea.offsetWidth;
	var height = textarea.offsetHeight;

	// hide the textarea
	textarea.style.display = "none";

	if (this.config.sizeIncludesToolbar) {
		// substract toolbar height
		height -= this._toolbar.offsetHeight;
	}

	// size the IFRAME according to user's prefs or initial textarea
	height = (this.config.height == "auto" ? (height + "px") : this.config.height);
	this._iframe.style.height = height + "px";
	width = (this.config.width == "auto" ? (width + "px") : this.config.width);
	this._iframe.style.width = width;
};