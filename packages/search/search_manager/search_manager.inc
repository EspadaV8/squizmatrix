<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Commercial Module Licence                                |
* +--------------------------------------------------------------------+
* | Copyright (c) Squiz Pty Ltd (ACN 084 670 600).                     |
* +--------------------------------------------------------------------+
* | This source file is not open source or freely usable and may be    |
* | used subject to, and only in accordance with, the Squiz Commercial |
* | Module Licence.                                                    |
* | Please refer to http://www.squiz.net/licence for more information. |
* +--------------------------------------------------------------------+
*
* $Id: search_manager.inc,v 1.74 2005/08/18 02:22:51 ndvries Exp $
*
*/
require_once SQ_INCLUDE_PATH.'/asset.inc';

/**
* Search_Manager
*
* Manages searching and relevance weights for attributes of asset types.
*
* @author  Marc McIntyre <mmcintyre@squiz.net>
* @author  Greg Sherwood <greg@squiz.net>
* @version $Revision: 1.74 $
* @package MySource_Matrix_Packages
* @subpackage search
*/
class Search_Manager extends Asset
{
	var $standard_date_fields = null;
	var $standard_text_fields = null;


	/**
	* Constructor
	*
	* @param int	$assetid	the asset id to be loaded
	*
	*/
	function Search_Manager($assetid=0)
	{
		$this->_ser_attrs = true;
		$this->Asset($assetid);
		$this->standard_date_fields = Array(
										'created'			=> translate('asset_created_date'),
										'updated'			=> translate('asset_updated_date'),
										'published'			=> translate('asset_published_date'),
										'status_changed'	=> translate('asset_status_changed_date'),
									  );
		$this->standard_text_fields = Array(
										'assetid'		=> translate('asset_id'),
										'name'			=> translate('asset_name'),
										'short_name'	=> translate('asset_name_short'),
										'contents'		=> translate('asset_contents'),
									  );

	}//end constructor


	/**
	* Create this asset
	*
	* @param array()	&$link	information used to create the initial link
	*
	* @see Asset::create()
	* @return mixed int or false
	* @access public
	*/
	function create(&$link)
	{
		require_once SQ_CORE_PACKAGE_PATH.'/system/system_asset_fns.inc';
		if (!system_asset_fns_create_pre_check($this)) {
			return false;
		}
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		if ($linkid = parent::create($link)) {
			if (!system_asset_fns_create_cleanup($this)) {
				$linkid = false;
			}
		}

		if ($linkid) {
			$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		} else {
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
		}

		return $linkid;

	}//end create()


	/**
	* Returns name of the asset
	*
	* @param bool	$short_name	whether or not we are after the shortname or the full name
	*
	* @see Asset::_getName()
	* @access private
	*/
	function _getName($short_name=false)
	{
		return $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($this->type(), 'name');

	}//end _getName()


	/**
	* Can this asset have its last significant link removed (putting it in the trash)?
	*
	* @return boolean
	* @access public
	*/
	function canDelete()
	{
		return false;

	}//end canDelete()


	/**
	* returns FALSE always because we don't want to be able to clone a search manager
	*
	* @return boolean
	* @access public
	*/
	function canClone()
	{
		return false;

	}//end canClone()


//--        ASSET INDEXING        --//


	/**
	* Event fired when an asset messages that it requires its internals
	* to be reindexed
	*
	* @param &object Asset	&$broadcaster	the asset that triggered the event
	* @param Array			$vars			the vars that get submitted by the broadcaster
	*										Component is set as $vars['component']
	*
	* @return boolean
	* @access public
	*/
	function onAssetUpdate(&$broadcaster, $vars=Array())
	{
		// don't run if indexing turned OFF
		if (!$this->attr('indexing')) return false;
		$this->reindexAsset($broadcaster, Array('asset'));

		return true;

	}//end onAssetUpdate()


	/**
	* Reindex this asset and, if specified, the metadata associated with this asset
	*
	* @param &object Asset		$asset		the asset to reindex
	* @param Array				$components	the components to reindex - 'asset' to
	*										reindex the core components of the asset, and
	*										'metadata' to reindex metadata or 'all' for both
	*
	* @return void
	* @access public
	*/
	function reindexAsset(&$asset, $components=Array('all'))
	{
		// if search manager is reindexed then there is infinite recursion!!!
		if ($asset->id == $this->id) return false;

		// check to see that there is an asset to index this data under
		if (!$indexing_assetid = $this->getIndexingAssetid($asset)) {
			return false;
		}

		if (in_array('all', $components) || in_array('asset', $components)) {
			$this->flushIndexableContent($indexing_assetid);
			$indexing_asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($indexing_assetid);
			$new_key_data = $this->getIndexableContent($indexing_asset);
			$this->addIndexableContent($indexing_assetid, $new_key_data);
		}
		if (in_array('all', $components) || in_array('metadata', $components)) {
			$this->reindexMetadata($indexing_assetid);
		}
		$GLOBALS['SQ_SYSTEM']->am->forgetAsset($assetid);
		$GLOBALS['SQ_SYSTEM']->am->forgetAsset($indexing_asset);

	}//end reindexAsset()


	/**
	* Event fired when an asset gets deleted. We want to flush ank key data in the index table
	*
	* @param &object Asset	&$broadcaster	the asset that triggered the event
	* @param Array		$vars		the vars that get submitted by the broadcaster
	*					Component is set as $vars['component']
	*
	* @return void
	* @access public
	*/
	function onAssetDeleted(&$broadcaster, $vars=Array())
	{
		return $this->flushIndexableContent($broadcaster->id);

	}//end onAssetDeleted()


	/**
	* Flush the keydata for an asset
	*
	* @param int		$assetid	ID of the asset
	* @param string		$component	the component to which the keydata pertains (e.g. metadata or attribute)
	*
	* @return void
	* @access public
	*/
	function flushIndexableContent($assetid, $component=null)
	{
		// don't run if indexing turned OFF
		if (!$this->attr('indexing')) return;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$sql = 'DELETE FROM
					sq_sch_idx
				WHERE
					assetid = '.$db->quoteSmart($assetid);
		if (!is_null($component)) {
			$sql .= ' AND component = '.$db->quoteSmart($component);
		}

		$result = $db->query($sql);
		assert_valid_db_result($result);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

	}//end flushIndexableContent()


	/**
	* Returns the assetid in which content should be indexed under for the specified asset
	*
	* @param &object Asset	$asset	the asset to find the indexing asset for
	*
	* @return mixed the assetid or false if there is no indexing asset
	* @access public
	*/
	function getIndexingAssetid(&$asset)
	{
		$links = $GLOBALS['SQ_SYSTEM']->am->getLinks($asset->id, SQ_SC_LINK_ALL, '', false, 'minor');
		if (empty($links)) return false;

		$parents = $GLOBALS['SQ_SYSTEM']->am->getDependantParents($asset->id);
		$parents = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo($parents, Array(), false, 'type_code');
		if (empty($parents)) return $asset->id;

		// the first dependant parent will be the first element on the array
		$parent = array_shift(array_keys($parents));

		return $parent;

	}//end getIndexingAssetid()


	/**
	* Returns the indexable content for the specified asset
	*
	* @param &object	Asset $asset	the asset to obtain the dineavle content for
	*
	* @return Array
	* @access public
	*/
	function getIndexableContent(&$asset)
	{
		require_once SQ_FUDGE_PATH.'/general/text.inc';

		$index_content = $this->getIndexableMetadataContent($asset);
		$weightings    = $this->getWeightings($asset->id);

		$type_code = $asset->type();

		// index the name and the short name
		foreach (Array('name', 'short_name') as $name_type) {
			$name_index = '__'.$name_type.'__';
			// if there are no weightings, we dont want to index this name
			if (!isset($weightings[$name_index])) continue;

			$name = ($name_type == 'name') ? strtolower($asset->name) : strtolower($asset->short_name);
			foreach (get_word_counts($name) as $word => $count) {
				$index_content[] = Array(
									'value'		=> $word,
									'type_code'	=> $type_code,
									'type'		=> 'text',
									'component'	=> $name_index,
									'score'		=> $count * $weightings[$name_index],
								   );
			}
		}

		if (isset($weightings['__assetid__'])) {
			$index_content[] = Array(
								'value'		=> $asset->id,
								'type_code'	=> $type_code,
								'type'		=> 'int',
								'component'	=> '__assetid__',
								'score'		=> $weightings['__assetid__'],
							   );
		}

		$dates = Array(
					'__created__'	=> $asset->created,
					'__updated__'	=> $asset->updated,
				 );
		if (!is_null($this->published)) {
			$dates['__published__'] = $asset->published;
		}
		if (!is_null($this->status_changed)) {
			$dates['__status_changed__'] = $asset->status_changed;
		}

		foreach ($dates as $type => $date) {
			// if there are no weightings, we don't want to index this date
			if (!isset($weightings[$type])) continue;

			$index_content[] = Array(
								'value'		=> ts_iso8601($date),
								'type_code'	=> $type_code,
								'type'		=> 'datetime',
								'component'	=> $type,
								'score'		=> $weightings[$type],
							   );
		}

		// only index this if there is a weighting set
		if (isset($weightings['contents'])) {
			// ask the asset for its content, and store it under a contents component
			// we don't want to index any tags so strip them
			$contents = strtolower(strip_tags(html_entity_decode($asset->getContent())));

			if (trim($contents) != '') {
				foreach (get_word_counts($contents) as $word => $count) {
					$index_content[] = Array(
										'value'		=> $word,
										'type_code'	=> $type_code,
										'type'		=> 'text',
										'component'	=> '__contents__',
										'score'		=> $count * $weightings['contents'],
									   );
				}
			}
		}

		foreach ($asset->vars as $var_name => $var_data) {

			// if there is no weightings for this attribute, then its not indexable
			if (!isset($weightings[$var_name])) continue;

			// don't index attribute that are names or short names as we index these
			// as part of the asset components
			if ($var_name == 'name' || $var_name == 'short_name') {
				//continue;
			}

			// don't index passwords
			if ($var_data['type'] == 'password') continue;

			$attribute = &$asset->getAttribute($var_name);
			$value = strtolower($attribute->getContent());
			if (empty($value)) continue;

			$comp_name = 'attr:'.$var_name;

			foreach (get_word_counts($value) as $word => $count) {
				$index_content[] = Array(
									'value'		=> $word,
									'type_code'	=> $type_code,
									'type'		=> $var_data['type'],
									'component'	=> $comp_name,
									'score'		=> $count * $weightings[$var_name],
								   );
			}
		}//end foreach asset vars

		return $index_content;

	}//end getIndexableContent()


	/**
	* Adds the sepecifed index content for the specified assetid to the indexing system
	*
	* @param string	$assetid		the assetid to index the content under
	* @param Array	$index_content	the content to index
	*
	* @return boolean
	* @access public
	*/
	function addIndexableContent($assetid, &$index_content)
	{
		// don't run if indexing turned OFF
		if (!$this->attr('indexing')) return false;
		if (!is_array($index_content)) return false;

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$param_data = Array();
		$keys = array_keys($index_content);
		foreach ($keys as $key) {
			$data = &$index_content[$key];
			$value = $data['value'];

			if (trim($value) == '') continue;

			switch ($data['type']) {
				case 'datetime':
					require_once SQ_FUDGE_PATH.'/general/datetime.inc';
					if (!is_iso8601($value)) {
						$value = ts_iso8601(strtotime($value));
					}
				break;

				case 'text':
					// filter noise words
					if (!$this->isWordIndexable($value)) continue 2; //continue the foreach loop

					require_once SQ_FUDGE_PATH.'/general/text.inc';
					foreach (get_word_counts($value) as $word => $count) {
						$param_data[] = Array(
											$word,
											$data['type_code'],
											$data['type'],
											$data['component'],
											$count * $data['score'],
										);
					}
					continue 2;

				// NOTE: break is omitted on purpose
				case 'thesaurus':
				case 'select':
					$value = strtolower($value);
				break;

				default:
					// nothing yet
			}

			$param_data[] = Array(
								$value,
								$data['type_code'],
								$data['type'],
								$data['component'],
								$data['score'],
							);
		}

		if (empty($param_data)) return false;

		$st = $db->prepare(
				'INSERT INTO
					sq_sch_idx
					(
						value,
						type_code,
						type,
						assetid,
						component,
						score
					)
					VALUES
					(
						?,
						?,
						?,
						'.$db->quote($assetid).',
						?,
						?
					)'
				);

		assert_valid_db_result($st);
		$result = $db->executeMultiple($st, $param_data);
		assert_valid_db_result($result);

		$db->freePrepared($st);

		return true;

	}//end addIndexableContent()


	/**
	* Returns a list of indexable compents for all assets
	*
	* @return Array ($component => $display_name)
	* @access public
	*/
	function getIndexableAssetComponents()
	{
		$components = Array(
						'__assetid__'			=> 'Asset ID',
						'__name__'				=> 'Asset Name',
						'__short_name__'		=> 'Asset Short Name',
						'__created__'			=> 'Created Date',
						'__updated__'			=> 'Updated Date',
						'__published__'			=> 'Published Date',
						'__status_changed__'	=> 'Status Changed Date',
						'contents'				=> 'Asset Contents',
					  );

		return $components;

	}//end getIndexableAssetComponents()


	/**
	* Returns a list of indexable components for a specified asset type
	*
	* @param string	$type_code the type code
	*
	* @return Array
	* @access public
	*/
	function getIndexableAttributes($type_code)
	{
		$attrs = $GLOBALS['SQ_SYSTEM']->am->getAssetTypeAttributes($type_code, Array('name', 'type', 'is_admin'));

		$indexable_attrs = Array();
		foreach ($attrs as $attr => $info) {
			if (!$attrs[$attr]['is_admin'] || $attrs[$attr]['is_admin'] == 'f') {
				$indexable_attrs[$attr] = $info;
			}
		}
		return $indexable_attrs;

	}//end getIndexableAttributes()


	/**
	* Returns TRUE if the specified attribute is indexable
	*
	* @param int	$attrid	the attribute id
	*
	* @return boolean
	* @access public
	*/
	function isAttributeIndexable($attrid)
	{
		$info = $GLOBALS['SQ_SYSTEM']->am->getAttributeInfo(Array($attrid));
		return !$info[$attrid]['is_admin'];

	}//end isAttributeIndexable()


	/**
	* Returns TRUE if the specified asset is indexable
	*
	* @param string	$assetid	the assetid to check
	*
	* @return boolean
	* @access public
	*/
	function isAssetIndexable($assetid)
	{
		$weights = $this->getAssetWeightings($assetid);
		return (isset($weights['indexed']) && $weights['indexed']);

	}//end isAssetIndexable()


	/**
	* Returns TRUE if the specified asset type is indexable
	*
	* @param string	$type_code	the type_code to check
	*
	* @return boolean
	* @access public
	*/
	function isTypeIndexable($type_code)
	{
		$weights = $this->getAssetTypeWeightings($type_code);
		return (isset($weights['indexed']) && $weights['indexed']);

	}//end isTypeIndexable()


	/**
	* Check if the word is indexable
	*
	* Check is performed according to the current indexing parameters
	*
	* @param string		$word	word to check
	*
	* @return boolean
	* @access public
	*/
	function isWordIndexable($word)
	{
		$min_length = $this->attr('min_word_length');
		return $this->isWhiteWord($word) || (strlen($word) >= $min_length && !$this->isNoiseWord($word));

	}//end isWordIndexable()


//--        METADATA INDEXING        --//


	/**
	* Event fired when metadata manager wants some metadata reindexed
	*
	* @param &object Asset	&$broadcaster	the asset that triggered the event (should be meta. mgr)
	* @param Array			$vars			the vars that get submitted by the broadcaster
	*										Asset ID is set as $vars['assetid']
	*										Schema Asset IDs is set as $vars['schemaids']
	*
	* @access public
	* @return void
	*/
	function onIndexMetadata(&$broadcaster, $vars=Array())
	{
		$this->reindexMetadata($vars['assetid']);

	}//end onIndexMetadata()


	/**
	* Re-indexes the metadata components for the specified asset
	*
	* @param string	$assetid	the assetid to reindex
	*
	* @return void
	* @access public
	*/
	function reindexMetadata($assetid)
	{
		assert_valid_assetid($assetid);
		$mm = &$GLOBALS['SQ_SYSTEM']->getMetadataManager();
		$fieldids = $mm->getMetadataFields($mm->getSchemas($assetid, true));

		foreach ($fieldids as $fieldid => $field_type) {
			$this->flushIndexableContent($assetid, 'metadata:'.$fieldid);
		}

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		$this->addIndexableContent($assetid, $this->getIndexableMetadataContent($asset, $fieldids));

	}//end reindexMetadata()


	/**
	* Returns the indexable metadata content for the specified asset
	*
	* @param &Object	Asset	$asset			The asset to get the indexable content fors
	* @param Array				$fieldids		Array of fieldid => type_code to limit to
	*
	* @return Array
	* @access public
	*/
	function getIndexableMetadataContent(&$asset, $fieldids=Array())
	{
		$index_content = Array();
		$mm = &$GLOBALS['SQ_SYSTEM']->getMetadataManager();
		$type_code = $asset->type();

		if (is_null($asset)) return $index_content;

		if (empty($fieldids)) {
			$fieldids = $mm->getMetadataFields($mm->getSchemas($asset->id, true));
		}
		$metadata = $mm->getMetadata($asset->id);
		foreach ($fieldids as $fieldid => $field_type) {

			// dont index this fieldid if getMetadataWeighting return false
			if (false === ($weighting = $this->getMetadataWeighting($asset->id, $fieldid))) {
				continue;
			}

			$field = &$GLOBALS['SQ_SYSTEM']->am->getAsset($fieldid, $field_type);

			if (isset($metadata[$field->id]['value'])) {
				$value = $metadata[$field->id]['value'];
			} else {
				$value = $field->attr('default');
			}
			$value_components = Array();
			Metadata_Field::decodeValueString($value, $value, $value_components);


			$force_processing = 1; // will tell the function to process values in any case

			// check field_type to define the indexing way
			if ($field_type == 'metadata_field_date') {
				$index_content[] = Array(
									'value'		=> $value,
									'type_code'	=> $type_code,
									'type'		=> 'datetime',
									'component'	=> 'metadata:'.$field->id,
									'score'		=> $weighting,
								   );
			} else {
				switch ($field_type) {
					case 'metadata_field_select':
						$key_type = 'selection';
					break;

					case 'metadata_field_thesaurus':
						$key_type = 'thesaurus';
					break;

					default:
						$key_type = 'text';
				}

				$keywords = retrieve_keywords_replacements($value, '.');
				$value = replace_keywords($value, $mm->generateKeywordReplacements($asset, $keywords, false));

				$word_counts = get_word_counts(strtolower($value));


				foreach ($word_counts as $word => $count) {
					$index_content[] = Array(
										'value'		=> $word,
										'type_code'	=> $type_code,
										'type'		=> $key_type,
										'component'	=> 'metadata:'.$field->id,
										'score'		=> $count * $weighting,
									   );
				}
			}//end if metadata_date
		}//end foreach fieldids

		return $index_content;

	}//end getIndexableMetadataContent()


//--        WEIGHTINGS        --//


	/**
	* Returns the weightings for an assets core components and its attributes
	*
	* The Following presedence rules are followed in order when finding the weightings for
	* a particular asset:
	*
	* <ul>
	*  <li> Any explicit weightings for the asset id are checked </li>
	*  <li> Any weightings for a tree in which the asset resides are checked</li>
	*  <li> Any weightings for a asset type are checked </li>
	*  <li> Any global weightings for all asset types are checked </li>
	*  <li> All components are returned a default weighing of 1</li>
	* </ul>
	*
	* @param string	$assetid 	the assetid to obtain the weightings for
	*
	* @return Array()
	* @access public
	*/
	function getWeightings($assetid)
	{
		// firstly, check if there are any weightings specific to this asset
		$weightings = $this->getAssetWeightings($assetid);

		if (empty($weightings)) {
			// if we can't find any weightings specific to this asset, check
			// to see if there are any tree weightings for this asset
			$weightings = $this->getAssetTreeWeightings($assetid, false);

			// if we can't find any tree weightings that this asset exists under
			// check the asset type weightings.
			if (empty($weightings)) {
				$type_code = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo(Array($assetid), Array(), true, 'type_code');
				$type_code = $type_code[$assetid];
				$weightings = $this->getAssetTypeWeightings($type_code);

				// if there are no type weightings, then we will have to create
				// some default values for this assetid
				if (empty($weightings)) {
					$weightings  = Array();
					$asset_comps = $this->getIndexableAssetComponents();
					$attr_comps  = $this->getIndexableAttributes($type_code);
					$components  = array_merge($asset_comps, $attr_comps);

					foreach (array_keys($components) as $component) {
						$weightings[$component] = 1;
					}
					return $weightings;
				}
			}
		}

		$indexed_weightings = Array();
		// only add the weightings if the individual components are indexed
		foreach (Array('attr_weights', 'asset_weights') as $type) {
			foreach ($weightings[$type] as $component => $info) {
				if ($info['indexed']) {
					$indexed_weightings[$component] = $info['weight'];
				}
			}
		}
		return $indexed_weightings;

	}//end getWeightings()


	/**
	* Returns the metadata weightings for the specified assetid and metadata fieldid
	*
	* The following presedence rules are followed in order when finding the weightings for
	* a particular asset:
	*
	* <ul>
	*  <li> Any explicit weightings for the asset id are checked </li>
	*  <li> Any weightings for a tree in which the asset resides are checked </li>
	*  <li> Any weightings for a asset type are checked </li>
	*  <li> Any global weightings for all asset types are checked </li>
	*  <li> A default weighing of 1 is returned </li>
	* </ul>
	*
	* @param string	$assetid 	the assetid to get the weightings for
	* @param string	$fieldid	the fieldid of the metadata field
	*
	* @return Array() or false if the fieldid should not be indexed
	* @access public
	*/
	function getMetadataWeighting($assetid, $fieldid)
	{
		$mm = &$GLOBALS['SQ_SYSTEM']->getMetadataManager();

		$section_link = $GLOBALS['SQ_SYSTEM']->am->getLink($fieldid, SQ_LINK_TYPE_2, 'metadata_section', true, null, 'minor');
		$schema_links = $GLOBALS['SQ_SYSTEM']->am->getLinks($section_link['majorid'], SQ_LINK_TYPE_2, 'metadata_schema', true, 'minor');
		$sectionid    = $section_link['majorid'];
		$schemaids    = Array();

		foreach ($schema_links as $schema_info) {
			$schemaids[] = $schema_info['majorid'];
		}

		$info      = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo(Array($fieldid), Array(), true, 'type_code');
		$type_code = $info[$fieldid];

		$weight_sources = Array(
							'Asset'		=> $assetid,
							'AssetTree'	=> $assetid,
							'AssetType'	=> $type_code,
						  );

		foreach ($weight_sources as $type => $key) {
			$fn = 'get'.$type.'weightings';
			$weightings = $this->$fn($key);
			if (!empty($weightings) && isset($weightings['metadata_weights'])) {
				$weight = $this->_getLocalMetadataWeightings($weightings['metadata_weights'], $fieldid, $sectionid, $schemaids);
				// if the weight is false then we don't want to index this field
				if ($weight === false) return false;
				// if the weight is not -1 then this is the wieght to use
				// otherwise continue to the next source
				if ($weight != -1) return $weight;
			}
		}

		// return a default weight of 1 for this field
		return 1;

	}//end getMetadataWeighting()


	/**
	* Returns the metadata weightings for a fieldid from the appropriate metadata asset
	*
	* Drills up the metadata tree going from the field => section => schema to find
	* any metadata weightings applicable for this field
	*
	* @param Array		$weightings	the weightigns to search
	* @param string		$fieldid	the fieldid of the metadata field
	* @param string		$sectionid	the sectionid that the field is a child of
	* @param string 	$schemaids	the schemaid that the section is a child of
	*
	* @return int	the weighting for the field or false if the fieldid is not to be indexed
	* 				-1 if no weighting could be found
	* @access private
	*/
	function _getLocalMetadataWeightings($weightings, $fieldid, $sectionid, $schemaids)
	{
		if (!empty($weightings)) {
			// check to see if there is an explicit weighting for the field
			if (isset($weightings[$fieldid])) {
				if (!$weightings[$fieldid]['indexed']) return false;
				return $weightings[$fieldid]['weight'];
			} else {
				// check for a weighting for the section that the field is under
				if (isset($weightings[$sectionid])) {
					if (!$weightings[$sectionid]['indexed']) return false;
					return $weightings[$sectionid]['weight'];
				} else {
					// check all the schemas that the section belongs under
					// its possible that this field is in multiple schemas, so find the
					// hightest weighting from all the schemas that it is under
					$highest_weight = -1;

					// check the index flag on all the schemas, and only turn off indexing
					// for this fieldid if all schemas have indexing off
					$index = false;

					foreach ($schemaids as $schemaid) {
						if (isset($weightings[$schemaid])) {
							if ($weightings[$schemaid]['indexed']) $index = true;
							if ($weightings[$schemaid]['weight'] > $highest_weight) {
								$highest_weight = $weightings[$schemaid]['weight'];
							}
						}
					}
					if (!$index) return false;
					if ($highest_weight != -1) return $highest_weight;

				}
			}
		}
		// no weight could be found
		return -1;

	}//end _getLocalMetadataWeightings()


	/**
	* Returns the Asset Type weightings for the specified asset type, or all
	* asset types if the specified type code is null
	*
	* @param string	$type_code	the type code of the wanted weightings, or null
	*							for all asset type weightings
	*
	* @return Array
	* @access public
	* @see saveTypeWeightings()
	*/
	function getAssetTypeWeightings($type_code=null, $strict_type_code=false)
	{
		$root_folder_assetid = $GLOBALS['SQ_SYSTEM']->am->getSystemAssetid('root_folder');
		// type weightings are stored under the root folder tree weightings
		$weights = $this->getAssetTreeWeightings($root_folder_assetid, true, true);

		$type_weights = array_get_index($weights, 'type_weights', Array());
		if (is_null($type_code)) return $type_weights;

		if (!$strict_type_code) {
			$type_hier = $GLOBALS['SQ_SYSTEM']->am->getTypeAncestors($type_code, true);
		} else {
			$type_hier = Array($type_code);
		}
		foreach ($type_hier as $type_code) {
			if (in_array($type_code, array_keys($type_weights))) {
				return $type_weights[$type_code];
			}
		}
		return Array();

	}//end getAssetTypeWeightings()


	/**
	* Returns the Asset Tree weightings for the specified assetid, or all
	* weightings registered for asset trees if the specified assetid is null
	*
	* @param string		$assetid			the assetid of the wanted tree weightings
	*										or null for all asset tree weightings
	*
	* @param boolean	$strict_assetid		if TRUE only weightings that have been
	*										customised explicitly using the specified assetid
	*										will be returned, otherwise the closest weighting
	*										customisation will be returned
	*
	* @param boolean	$strict_type_code	if TRUE only weightings matching the asset type of the
	*										specified assetid will be returned
	*
	* @return Array
	* @access public
	* @see saveTypeWeightings()
	*/
	function getAssetTreeWeightings($assetid=null, $strict_assetid=true, $strict_type_code=false)
	{
		$weightings_file = $this->data_path.'/asset_tree_weightings.inc';
		if (file_exists($weightings_file)) {
			require $weightings_file;

			if (!is_null($assetid)) {

				if ($strict_assetid) {
					if (isset($asset_tree_weightings[$assetid])) {
						return $asset_tree_weightings[$assetid];
					}
				} else {
					$type_code = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo(Array($assetid), Array(), true, 'type_code');
					$type_code = $type_code[$assetid];
					// firstly, check to see if there is an explicit entry for this assetid
					if (isset($asset_tree_weightings[$assetid]['type_weights'][$type_code])) {
						return $asset_tree_weightings[$assetid]['type_weights'][$type_code];
					}

					// there is no explicit weighting customisation for the assetid
					// so do a tree lookup for the closest one. getParents ORDER's by treeid
					// by default so we can be garunteed that the closest assetids are at the top of the array
					$parents = $GLOBALS['SQ_SYSTEM']->am->getParents($assetid);
					$closest_parentid = 0;

					foreach (array_keys($parents) as $parentid) {
						if (in_array($parentid, array_keys($asset_tree_weightings))) {

							// check to see if there are any customisations under this
							// tree for the specified asset type. Note that tree proximity supersedes
							// the type hierachy, so search the type hierachy if applicable
							if (!$strict_type_code) {
								$type_hier = $GLOBALS['SQ_SYSTEM']->am->getTypeAncestors($type_code, true);
								// add the current type code so that we can also find
								// weightings for this type, not just its parent types
								$type_hier[] = $type_code;
							} else {
								$type_hier = Array($type_code);
							}
							foreach ($type_hier as $type_code) {
								if (in_array($type_code, array_keys($asset_tree_weightings[$parentid]['type_weights']))) {
									$closest_parentid = $parentid;
									break;
								}
							}
						}
					}
					if ($closest_parentid != 0) {
						return $asset_tree_weightings[$closest_parentid]['type_weights'][$type_code];
					}
				}//end if strict_assetid
			} else {
				return $asset_tree_weightings;
			}//end if !is_null(assetid)
		}//end if file_exists

		return Array();

	}//end getAssetTreeWeightings()


	/**
	* Saves the asset tree weightings to file
	*
	* @param Array	$asset_tree_weightings	the complete asset tree weightings to save
	*
	* @return boolean
	* @access public
	*/
	function saveAssetTreeWeightings($asset_tree_weightings)
	{
		return $this->_saveWeightings($asset_tree_weightings, 'asset_tree');

	}//end saveAssetTreeWeightings()


	/**
	* Returns the Asset Type weightings
	*
	* @param string	$assetid	the assetid of the wanted weightings
	*							if null, weightings for all assets set will be returned
	*
	* @return Array
	* @access public
	* @see saveTypeWeightings()
	*/
	function getAssetWeightings($assetid=null)
	{
		$weightings_file = $this->data_path.'/asset_weightings.inc';
		if (file_exists($weightings_file)) {
			require $weightings_file;
			if (!is_null($assetid)) {
				if (isset($asset_weightings[$assetid])) {
					return $asset_weightings[$assetid];
				}
			} else {
				return $asset_weightings;
			}
		}
		return Array();

	}//end getAssetWeightings()


	/**
	* Saves the Asset Weightings
	*
	* @param array	$type_weights	the array of weights to save
	*
	* @return boolean
	* @access public
	* @see getTypeWeightings
	*/
	function saveAssetWeightings($asset_weightings)
	{
		return $this->_saveWeightings($asset_weightings, 'asset');

	}//end saveAssetWeightings()


	/**
	* Returns the Asset Type weightings
	*
	* @param string	$assetid	the assetid of the wanted weightings
	*							if null, weightings for all assets set will be returned
	*
	* @return Array
	* @access public
	* @see saveTypeWeightings()
	*/
	function getMetadataWeightings($assetid=null)
	{
		$weightings_file = $this->data_path.'/metadata_weightings.inc';
		if (file_exists($weightings_file)) {
			require $weightings_file;
			if (!is_null($assetid)) {
				if (isset($metadata_weightings[$assetid])) {
					return $metadata_weightings[$assetid];
				}
			} else {
				return $metadata_weightings;
			}
		}
		return Array();

	}//end getMetadataWeightings()


	/**
	* Saves the metadata weightings to file
	*
	* @param $metadata_weightings	the complete metadata weightings to save
	*
	* @return boolean
	* @access public
	*/
	function saveMetadataWeightings($metadata_weightings)
	{
		return $this->_saveWeightings($metadata_weightings, 'metadata');

	}//end saveMetadataWeightings()


	/**
	* Saves the weightings to the specified file
	*
	* @param array	$weightings the weightings to save
	* @param string	$type		the type of weightings, which should be one of
	*							asset_type, asset, asset_tree
	*
	* @return boolean
	* @access private
	*/
	function _saveWeightings($weightings, $type)
	{
		if (!in_array($type, Array('asset_type', 'asset', 'asset_tree', 'metadata'))) {
			trigger_error('Invalid weightings type "'.$type.'"', E_USER_ERROR);
			return false;
		}
		$weightings_file = $this->data_path.'/'.$type.'_weightings.inc';

		$output = '<'.'?php'."\n".' $'.$type.'_weightings = ';
		$output .= var_export($weightings, true);
		$output .= "\n?".'>';

		require_once SQ_FUDGE_PATH.'/general/file_system.inc';

		create_directory($this->data_path);
		if (!string_to_file($output, $weightings_file)) {
			trigger_error('Could not write out the '.str_replace('_', ' ', $type).' weightings to file', E_USER_WARNING);
			return false;
		}
		return true;

	}//end _saveWeightings()


//--        KEYWORD EXTRACTION        --//


	/**
	* Extracts keywords from the indexing table and ranks them in order of descending importance
	*
	* @param object Asset	&$asset	The asset whose keywords are to be extracted
	* @param boolean	$include_metadata	If false, metadata components are excluded
	* @param boolean	$include_scores	Determines whether scores are returned (true) or just
	*									the keywords (false). Affects return value.
	*
	* @return Array	depends on $include_scores:
	*				false: Array(string) containing keywords ordered in decreasing total score
	*				true: Array(string => int) score array indexed by keyword, ordered same way
	* @access public
	*/
	function extractKeywords(&$asset, $include_metadata=false, $include_scores=false)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = 'SELECT
					LOWER(value) as keyword, SUM(score) as total_score
				FROM
					sq_sch_idx
				WHERE
					assetid = '.$db->quoteSmart($asset->id).
				  ($include_metadata ? '' : ' AND component NOT LIKE '.$db->quoteSmart('metadata:%')).'
				GROUP BY
					keyword
				ORDER BY
					total_score DESC';

		$result = $db->getAssoc($sql);
		assert_valid_db_result($result);

		// force lowercase keys (= keywords) - CASE_LOWER is default for this function
		$result = array_change_key_case($result);

		if ($include_scores) {
			return $result;				// return result with scores
		} else {
			return array_keys($result);	// just return the keywords
		}

	}//end extractKeywords()


//--        SEARCH PROCESSING        --//


	/**
	* Generates a word list from the search string
	*
	* @param string	$words	the words string
	*
	* @return Array()
	* @access public
	*/
	function generateWordList($words)
	{
		if (!is_array($words)) {
			$words = split(' +', strtolower($words));
			foreach (array_keys($words) as $i) {
				// convert wildcard symbols to corresponding SQL wildcards
				$words[$i] = strtr($words[$i], '*?', '%_');

				// if this is an email, skip the following check...
				$at_pos  = strpos($words[$i], '@');
				$dot_pos = strpos($words[$i], '.');
				if ($at_pos === false && $dot_pos === false) {
					// preserve the wildcard symbols - i.e. don't quote them
					if (ereg('^[A-z%_0-9]+$', $words[$i])) {
							$words[$i] = addslashes($words[$i]);
					} else {
						unset($words[$i]);
					}
				}
			}
		}
		return $words;

	}//end generateWordList()


	/**
	* Processes a search request
	*
	* Formulates search query and returns the results
	*
	* Each search request is logged to the 'search' log in the format:
	* <PRE>
	* Array('terms'   => array (
	*						first term => count of result assets for this term only
	*						second term => ...
	*						),
	*		'results' => total number of result assets for this request,
	*		'assetid' => id of the asset requesting this search
	* );
	* </PRE>
	* This array will be in the 'data' section of the log entry (to be accessed via the log manager)
	*
	* @param array	$search_info	an array of search settings in the form
	* <PRE>
	* 'requester'	=> ID of asset that requested the search
	* 'asset_types'	=> Array of type code => whether to inherit
	* 'statuses'	=> Array of asset statuses, or empty array for default of live+
	* 'roots'		=> Array of assetids to use as roots for the search
	* 'root_logic'	=> 'AND'|'OR', depending on whether we want a result to be under all roots or any root
	* 'fields'		=> Array(
	*					field_name	=> Array(
	*									'words'				=> 'cat sat mat',
	*									'word_logic'		=> 'AND'|'OR' (all words or any word, default 'AND')
	*									'data_source_logic'	=> 'AND'|'OR' (all DSes or any DS, default 'OR')
	*									'data_sources'		=> Array(
	*															i	=> Array(
	*																	'type'		=> 'asset_attrib' for eg
	*																	'params'	=> Array(...)
	*																   ),
	*														   ),
	*								   ),
	*				   ),
	* 'field_logic'	=> 'AND'|'OR', depending on whether we want results that match all fields or any field
	* 'exclude'		=> Array of words to exclude from results
	* </PRE>
	* @param bool	$include_context	Whether to include the context in which the match was found
	*
	* @return array	(i => Array('assetid'=>x, 'search_score'=>y, 'source'=>z)) if include_context = true
	*				(assetid => total score) otherwise
	* @access public
	*/
	function processSearch($search_info, $include_context=false)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		require_once SQ_INCLUDE_PATH.'/general_occasional.inc'; // will definitely need this later.

		  /////////////////////////////
		 //  CONSTRUCT CACHING KEY  //
		/////////////////////////////
		// we need the cache manager to cache the results of queries
		$cm = &$GLOBALS['SQ_SYSTEM']->am->getSystemAsset('cache_manager');
		if (empty($search_info['roots'])) {
			$search_cache_key = 'systemWide';
		} else {
			$search_cache_key = implode(',', $search_info['roots']);
		}
		if (isset($search_info['statuses'])) {
			$search_cache_key .= implode(':', $search_info['statuses']);
		}
		if (isset($search_info['asset_types'])) {
			foreach ($search_info['asset_types'] as $type => $inherit) {
				$search_cache_key .= $type.($inherit ? 'i' : 'n').':';
			}
		}
		$search_cache_key .= 'RL='.array_get_index($search_info, 'root_logic', 'OR');
		if ($include_context) {
			$search_cache_key .= 'includeContext';
		}
		$this->_tmp['cache_key'] = $search_cache_key;
		$this->_tmp['cm'] =& $cm;

		  ///////////////////////////////////
		 //  CONSTRUCT BASE SEARCH QUERY  //
		///////////////////////////////////
		$base_query = $this->constructBaseSearchQuery($search_info);
		$base_query['select'][] = 'a.assetid';
		$base_query['select'][] = 'SUM(ai.score) as search_score';
		$base_query['from'][] = 'sq_sch_idx ai';
		$base_query['where'][] = 'ai.assetid = a.assetid';
		$base_query['group_by'][] = 'a.assetid';
		if ($include_context) {
			$base_query['select'][] = 'ai.component as source';
			$base_query['group_by'][] = 'ai.component';
		}

		  //////////////////////////
		 //  PROCESS EACH FIELD  //
		//////////////////////////
		$field_logic = array_get_index($search_info, 'field_logic', 'OR');
		$final_results = null;
		$term_totals = Array();
		foreach ($search_info['fields'] as $field_name => $field_details) {
			$field_results = null;
			$word_logic = array_get_index($field_details, 'word_logic', 'AND');
			$data_source_logic = array_get_index($field_details, 'data_source_logic', 'OR');
			$this->_prepareSearchField($field_details);
			if (empty($field_details['words'])) continue;
			$search_type = (isset($field_details['words']['from']) && isset($field_details['words']['to'])) ? 'date' : 'word';
			foreach ($field_details['data_sources'] as $data_source) {
				if ($search_type == 'date') {
					$data_source_results = $this->_processDateSearch($field_details['words'], $data_source, $base_query);
				} else {
					$data_source_results = null;
					foreach ($field_details['words'] as $search_term) {
						$term_results = $this->_processWordSearch($search_term, $data_source, $base_query);
						$term_totals[$search_term] = array_get_index($term_totals, $search_term, 0) + count($term_results);
						$data_source_results = $this->_combineResults($data_source_results, $term_results, $word_logic);
					}
				}
				$field_results = $this->_combineResults($field_results, $data_source_results, $data_source_logic);
			}
			$final_results = $this->_combineResults($final_results, $field_results, $field_logic);
		}

		  //////////////////////////////
		 //  PROCESS EXCLUDED TERMS  //
		//////////////////////////////
		if (!empty($search_info['exclude'])) {
			$words = Array();
			foreach ($search_info['exclude'] as $exclude_value) {
				$words = array_merge($words, $this->generateWordList($exclude_value));
			}
			$words = array_unique($words);
			$new_base = $base_query;
			$new_base['where'][] = 'ai.value LIKE \'%'.implode("%' OR ai.value LIKE '%", $words).'%\'';
			$new_base['select'] = Array('a.assetid');
			$new_base['group_by'] = Array('a.assetid');
			$sql = implode_sql($new_base);
			$result = $db->getCol($sql);
			assert_valid_db_result($result);

			foreach ($result as $exclude_assetid) {
				if (isset($final_results[$exclude_assetid])) {
					unset($final_results[$exclude_assetid]);
				}
			}
		}

		  ///////////////////////
		 //  LOG THIS SEARCH  //
		///////////////////////
		if (!empty($search_info['requester'])) {
			$log_contents['terms']   = $term_totals;
			$log_contents['results'] = count($final_results);
			$log_contents['assetid'] = $search_info['requester'];
			log_write($log_contents, 'search');
		}

		return $final_results;

	}//end processSearch()


	/**
	* Prepares the supplied search field for searching
	*
	* If all datasources are of type datetime, makes sure the 'words' array is appropriately set up as a
	* date range.  Otherwise gets the words from the search string, makes them into an array and removes
	* unindexable words
	*
	* Data sources that are not properly initialised are removed
	*
	* @param array	$field_details	One entry from the 'fields' array in processSearch()'s search_info parameter
	*
	* @access private
	* @return void
	*/
	function _prepareSearchField(&$field_details)
	{
		if (empty($field_details['data_sources'])) {
			$field_details['data_sources'] = Array();
			return;
		}

		// figure out if we should treat this field as a date/time range
		$is_datetime = true;
		foreach ($field_details['data_sources'] as $i => $data_source) {
			switch ($data_source['type']) {

				case 'asset_attrib':
					$asset_type = array_get_index($data_source['params'], 'asset_type');
					$attrid = array_get_index($data_source['params'], 'attrid');
					if (empty($asset_type) || empty($attrid)) {
						unset($field_details['data_sources'][$i]);
						continue;
					}
					$attribute = &$GLOBALS['SQ_SYSTEM']->am->getAttribute($attrid);
					if (is_null($attribute)) {
						unset($field_details['data_sources'][$i]);
						continue;
					}
					if (!is_a($attribute, 'asset_attribute_datetime')) {
						$is_datetime = false;
						break(2);
					}
				break;

				case 'metadata':
					if (empty($data_source['params']['assetid'])) {
						unset($field_details['data_sources'][$i]);
						continue;
					}
					$metadata_field = &$GLOBALS['SQ_SYSTEM']->am->getAsset($data_source['params']['assetid']);
					if (is_null($metadata_field)) {
						unset($field_details['data_sources'][$i]);
						continue;
					}
					if (!is_a($metadata_field, 'metadata_field_date')) {
						$is_datetime = false;
						break(2);
					}
				break;

				case 'standard':
					$asset_field = array_get_index($data_source['params'], 'field');
					if (empty($asset_field)) {
						unset($field_details['data_sources'][$i]);
						continue;
					}
					if (isset($this->standard_text_fields[$asset_field])) {
						$is_datetime = false;
						break(2);
					} else if (!isset($this->standard_date_fields[$asset_field])) {
						trigger_error('Invalid standard field "'.$asset_field.'"', E_USER_WARNING);
						break(2);
					}
				break;

				case 'include_all':
					$is_datetime = false;
					break(2);
				break;

				default:
					trigger_error('Unknown data source type '.$data_source['type'], E_USER_WARNING);
				break;

			}//end switch
		}//end foreach data source

		if ($is_datetime) {
			$from = array_get_index($field_details['words'], 'from', '---------- --:--:--');
			$to = array_get_index($field_details['words'], 'to', '---------- --:--:--');
			if ($from != '---------- --:--:--') {
				$from = str_replace('--:--:--', '00:00:00', $from);
			}
			if ($to != '---------- --:--:--') {
				$to = str_replace('--:--:--', '23:59:59', $to);
			}
			$field_details['words'] = Array('from' => $from, 'to' => $to);
		} else {
			// remove unindexable words
			$words = Array();
			foreach ($this->generateWordList($field_details['words']) as $word) {
				if ($this->isWordIndexable($word)) $words[] = $word;
			}
			$field_details['words'] = $words;
		}

	}//end _prepareSearchField()


	/**
	* Processes a search for a particular word in a particular data source
	*
	* @param string	$search_term	Word to search for
	* @param array	$data_source	Details of the data source to search in
	* @param array	$base_query		The base of the sql query to use
	*
	* @access public
	* @return array (assetid => count), or (i => array('assetid'=>x, 'search_score'=>y, 'source'=>z)
	*/
	function _processWordSearch($search_term, $data_source, $base_query)
	{
		$db =& $GLOBALS['SQ_SYSTEM']->db;

		$cache_key = $this->_tmp['cache_key'].$data_source['type'];
		switch ($data_source['type']) {
			case 'asset_attrib':
				$cache_key .= $data_source['params']['attrid'];
			break;

			case 'metadata':
				$cache_key .= $data_source['params']['assetid'];
			break;

			case 'standard':
				$cache_key .= $data_source['params']['field'];
			break;
		}
		$cache_key .= $search_term;

		$result = $this->_tmp['cm']->loadFromCache($this->id, $this->type(), $cache_key);
		if (empty($result)) {
			switch ($data_source['type']) {

				case 'include_all':
					$base_query['where'][] = 'ai.value LIKE '.$db->quote('%'.$search_term.'%');
				break;

				case 'asset_attrib':
					$attribute = &$GLOBALS['SQ_SYSTEM']->am->getAttribute($data_source['params']['attrid']);
					$base_query['where'][] = 'ai.component = '.$db->quote('attr:'.$attribute->name);
					$base_query['where'][] = 'ai.value LIKE '.$db->quote('%'.$search_term.'%');
				break;

				case 'metadata':
					$metadata_field = &$GLOBALS['SQ_SYSTEM']->am->getAsset($data_source['params']['assetid']);
					$key_types = Array(
									'metadata_field_select'		=> 'selection',
									'metadata_field_thesaurus'	=> 'thesaurus',
								 );
					$key_type = array_get_index($key_types, get_class($metadata_field), 'text');
					$base_query['where'][] = 'ai.type = '.$db->quote($key_type);
					$base_query['where'][] = 'ai.component = '.$db->quote('metadata:'.(int)$data_source['params']['assetid']);
					$base_query['where'][] = 'ai.value LIKE '.$db->quote('%'.$search_term.'%');
				break;

				case 'standard':
					$field = $data_source['params']['field'];
					if (isset($this->standard_text_fields[$field])) {
						$base_query['where'][] = 'ai.component = '.$db->quote('__'.$field.'__');
						$base_query['where'][] = 'ai.value LIKE '.$db->quote('%'.$search_term.'%');
					} else {
						trigger_error('Invalid standard search field '.$field, E_USER_WARNING);
					}
				break;

			}

			$sql = implode_sql($base_query);
			if (count($base_query['select']) > 2) {
				$result = $db->getAll($sql);
			} else {
				$result = $db->getAssoc($sql);
			}
			assert_valid_db_result($result);
			$r = $this->_tmp['cm']->saveToCache($this->id, $this->type(), $cache_key, serialize($result));
			assert_valid_cache_result($r);
		} else {
			$result = unserialize($result);
		}
		return $result;

	}//end _processWordSearch()


	/**
	* Search for a date range in a particular data source
	*
	* @param string	$date_range		Range of dates to search for
	* @param array	$data_source	Details of the data source to search in
	* @param array	$base_query		The base of the sql query to use
	*
	* @access public
	* @return void
	*/
	function _processDateSearch($date_range, $data_source, $base_query)
	{
		$db =& $GLOBALS['SQ_SYSTEM']->db;

		$cache_key = $this->_tmp['cache_key'].$data_source['type'];
		switch ($data_source['type']) {
			case 'asset_attrib':
				$cache_key .= $data_source['params']['attrid'];
			break;

			case 'metadata':
				$cache_key .= $data_source['params']['assetid'];
			break;

			case 'standard':
				$cache_key .= $data_source['params']['field'];
			break;
		}
		$cache_key .= 'from'.$date_range['from'].'to'.$date_range['to'];

		$result = $this->_tmp['cm']->loadFromCache($this->id, $this->type(), $cache_key);
		if (empty($result)) {
			switch ($data_source['type']) {

				case 'asset_attrib':
					// TODO: restrict by asset type here?
					$attribute = &$GLOBALS['SQ_SYSTEM']->am->getAttribute($data_source['params']['attrid']);
					$base_query['where'][] = 'ai.component = '.$db->quote('attr:'.$attribute->name);
				break;

				case 'metadata':
					$metadata_field = &$GLOBALS['SQ_SYSTEM']->am->getAsset($attr_info['params']['assetid']);
					$key_types = Array(
									'metadata_field_select'		=> 'selection',
									'metadata_field_thesaurus'	=> 'thesaurus',
								 );
					$key_type = array_get_index($key_types, get_class($metadata_field), 'text');
					$base_query['where'][] = 'ai.type = '.$db->quote($key_type);
					$base_query['where'][] = 'ai.component = '.$db->quote('metadata:'.(int)$attr_info['params']['assetid']);
				break;

				case 'standard':
					$field = $data_source['params']['field'];
					if (isset($this->standard_date_fields[$field])) {
						$base_query['where'][] = 'ai.component = '.$db->quote('__'.$field.'__');
					} else {
						trigger_error('Invalid standard date search field '.$field, E_USER_WARNING);
					}
				break;

			}
			$base_query['where'][] = 'ai.value BETWEEN '.$db->quote($date_range['from']).' AND '.$db->quote($date_range['to']);
			$sql = implode_sql($base_query);
			if (count($base_query['select']) > 2) {
				$result = $db->getAll($sql);
			} else {
				$result = $db->getAssoc($sql);
			}
			assert_valid_db_result($result);
			$r = $this->_tmp['cm']->saveToCache($this->id, $this->type(), $cache_key, serialize($result));
			assert_valid_cache_result($r);
		} else {
			$result = unserialize($result);
		}
		return $result;

	}//end _processDateSearch()


	/**
	* Combine new results with results so far
	*
	* If $results_so_far is null, $new_results are always returned.  Otherwise if logic is 'AND'
	* the return value contains only the results that are in both the first two params, with
	* search scores added.  If logic is 'OR' then the return value contains all results that are
	* in either of the first two params, with search scores added for common results.
	*
	* This function can handle results with or without context (ie getAll or getAssoc return format)
	*
	* @param array	$results_so_far	Results so far.  Null if no results so far
	* @param array	$new_results	New results
	* @param string	$logic	'AND'|'OR'
	*
	* @access public
	* @return Array
	*/
	function _combineResults($results_so_far, $new_results, $logic)
	{
		if (is_null($results_so_far)) {
			return $new_results;
		} else {
			if ($logic == 'OR') {
				$res_results = $results_so_far;
			} else {
				$res_results = Array();
			}
			if (isset($results_so_far[0])) {
				// getAll format, rather than getAssoc format
				foreach ($new_results as $new_result) {
					$added = false;
					$found = false;
					foreach ($results_so_far as $i => $old_result) {
						if ($old_result['assetid'] == $new_result['assetid']) {
							$found = true;
							if ($old_result['source'] == $new_result['source']) {
								if ($logic == 'AND') {
									$old_result['search_score'] += $new_result['search_score'];
									$res_results[] = $old_result;
								} else {
									$res_results[$i]['search_score'] += $new_result['search_score'];
								}
								$added = true;
								break;
							} else if ($logic == 'AND') {
								// the assetid is common even though the source isn't, so the
								// existing entry deserves to stay
								$res_results[] = $old_result;
							}
						}
					}
					if (!$added && ($found || ($logic == 'OR'))) {
						// we haven't added it yet and either the logic is "OR" or the assetid is common
						// so we add the new result now
						$res_results[] = $new_result;
					}
				}
			} else {
				foreach ($new_results as $assetid => $score) {
					if ($logic == 'OR') {
						$res_results[$assetid] = $score + array_get_index($results_so_far, $assetid);
					} else if (isset($results_so_far[$assetid])) {
						$res_results[$assetid] = $score + $results_so_far[$assetid];
					}
				}
			}
			return $res_results;
		}

	}//end _combineResults()


	/**
	* Processes a basic search request without search terms
	*
	* Accepts the same input array as processSearch but does not use any search terms
	*
	* @param array	$search_info	an array of search settings
	*
	* @return array
	* @access public
	* @see processSearch()
	*/
	function processBasicSearch($search_info)
	{
		require_once SQ_INCLUDE_PATH.'/general_occasional.inc'; // will definitely need this later.
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$query_comps = $this->constructBaseSearchQuery($search_info);
		if (empty($query_comps)) return Array();
		$query_comps['select'][] = 'distinct a.assetid';
		$query_comps['select'][] = '1 as weight';
		$search_sql = implode_sql($query_comps);

		$search_results = Array();
		if (isset($search_info['limit'])) {
			// limiting the search results
			$result = $db->limitQuery($search_sql, 0, $search_info['limit']);
			assert_valid_db_result($result);

			while ($result->fetchInto($row, DB_FETCHMODE_ASSOC)) {
				$search_results[$row['assetid']] = 1;
			}
		} else {
			$search_results = $db->getAssoc($search_sql);
			assert_valid_db_result($search_results);
		}

		return $search_results;

	}//end processBasicSearch()


	/**
	* Checks a word against a thesaurus asset for synonyms
	*
	* @param string				$word		the word being checked
	* @param object Thesaurus	$thesaurus	thesaurus asset being used
	*
	* @return Array(string)	the list of suggestions
	* @access public
	*/
	function findSynonymsForWord($word, &$thesaurus)
	{
		if (!is_a($thesaurus, 'thesaurus')) {
			// why did you pass us a lemon instead of a thesaurus?
			trigger_localised_error('SCH0008', E_USER_WARNING, $thesaurus->getName(), $thesaurus->id);
			return Array();
		}

		$entity = $thesaurus->getEntityByName($word);

		if (empty($entity)) return Array();

		$relation = $thesaurus->getRelationByName('Synonyms');

		return $thesaurus->getChildEntitiesInRelation($relation['id'], $entity['id']);

	}//end findSynonymsForWord()


	/**
	* Spell-checks a word and returns a list of suggestions if available
	*
	* This function checks for the existence of the pSpell extension. If it does
	* not exist (eg. Windows server), or an error otherwise occurs in the loading
	* of the pSpell instance, we will proceed as if no suggestions are available.
	*
	* @param string	$word		the word to be checked
	* @param string $language	the language to be used to spell-check
	*
	* @return Array(string)	the list of suggestions, one considered most relevant
	*						by pSpell in index zero, and so on
	* @access public
	*/
	function spellCheckWord($word, $language='en')
	{
		if (!$this->spellCheckAvailable()) {
			// spell check not available, bugger
			return Array();
		}

		$pspell_config = pspell_config_create($language);
		pspell_config_mode($pspell_config, PSPELL_FAST);
		$pspell_instance = pspell_new_config($pspell_config);

		if (!$pspell_instance) return Array();

		$check_spelling = true;

		// ignore numbers
		if ($check_spelling) {
			$converted_word = (int)$word;
			if ((string)$converted_word == $word) {
				$check_spelling = false;
			}
		}

		// ignore words in all uppercase
		if ($check_spelling) {
			$converted_word = strtoupper($word);
			if ($converted_word == $word) $check_spelling = false;
		}

		// if we aren't checking spelling OR word is correct, return no suggestions
		if (!$check_spelling || pspell_check($pspell_instance, $word)) {
			return Array();
		} else {
			// word incorrect, if any suggestions then return them
			$suggestions = pspell_suggest($pspell_instance, $word);
			return $suggestions;
		}

	}//end spellCheckWord()


	/**
	* Returns true if the spell checker is available
	*
	* Written as a wrapper function so that if the spell-checker changes for some
	* reason, then this can be updated. It currently just checks whether the
	* pSpell extension is available.
	*
	* @return boolean
	* @access public
	*/
	function spellCheckAvailable()
	{
		return extension_loaded('pspell');

	}//end spellCheckAvailable()


	/**
	* Populates a search query array given an array of search settings
	*
	* Accepts the same search info array as processSearch()
	* Does not put the search index table or anything like that in the query
	*
	* @param array	$search_info	an array of search settings
	*
	* @return array	Components of search query in a format ready for implode_sql()
	* @access public
	* @see processSearch(), general_occasional::implode_sql
	*/
	function constructBaseSearchQuery($search_info)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$query = Array(
					'select'		=> Array(),
					'from'			=> Array('sq_ast a'),
					'where'			=> Array(),
					'where_joiner'	=> 'AND',
					'order_by'		=> Array(),
				 );

		// TREE LOCATIONS
		if (!empty($search_info['roots'])) {
			$root_logic = array_get_index($search_info, 'root_logic', 'OR');
			// get the treeids of our search roots
			$treeid_sql = 'SELECT l.minorid, t.treeid
						   FROM sq_ast_lnk_tree t
							   JOIN sq_ast_lnk l on t.linkid = l.linkid
						   WHERE l.minorid IN ('.implode(',', $search_info['roots']).')';
			// getAssoc only gives us the first treeid for each minorid, which is actually just what we want!
			$root_tree_ids = $db->getAssoc($treeid_sql);
			assert_valid_db_result($root_tree_ids);

			if ($root_logic == 'AND') {
				foreach (array_values($search_info['roots']) as $i => $rootid) {
					$query['from'][] = 'sq_ast_lnk al'.$i;
					$query['from'][] = 'sq_ast_lnk_tree t'.$i;
					$query['where'][] = 'al'.$i.'.linkid =  t'.$i.'.linkid'; // join the link tree and link tables
					$query['where'][] = 'al'.$i.'.minorid = a.assetid'; // join them to the asset table
					$treeid = $root_tree_ids[$rootid];
					$query['where'][] = 't'.$i.'.treeid LIKE '.$db->quote($treeid.'%');
				}
			} else {
				$query['from'][] = 'sq_ast_lnk al';
				$query['from'][] = 'sq_ast_lnk_tree t';
				$query['where'][] = 'al.linkid = t.linkid';
				$query['where'][] = 'al.minorid = a.assetid';

				$treeid_wheres = Array();
				foreach ($root_tree_ids as $treeid) {
					$treeid_wheres[] = '(t.treeid LIKE '.$db->quote($treeid.'%').')';
				}
				$query['where'][] = implode(' OR ', $treeid_wheres);
			}
		}

		// ACCESS RESTRICTIONS
		$user_restrictions = (!$GLOBALS['SQ_SYSTEM']->userRoot() && !$GLOBALS['SQ_SYSTEM']->userSystemAdmin());
		if ($user_restrictions) {
			$query['from'][] = 'sq_ast_perm ap';
			$query['where'][] = 'a.assetid = ap.assetid';
			$userids = array_keys($GLOBALS['SQ_SYSTEM']->am->getParents($GLOBALS['SQ_SYSTEM']->user->id, 'user_group', false));
			array_push($userids, 0, (int) $GLOBALS['SQ_SYSTEM']->user->id);
			for (reset($userids); NULL !== ($i = key($userids)); next($userids)) {
				$userids[$i] = $db->quote($userids[$i]);
			}
			$query['where'][] = 'ap.userid  IN ('.implode(',', $userids).')';
		}

		// STATUS RESTRICTIONS
		if (!empty($search_info['statuses'])) {
			$statuses = $search_info['statuses'];
			if (array_sum($statuses) != SQ_SC_STATUS_ALL) {
				foreach ($statuses as $i => $status) {
					$statuses[$i] = $db->quote($status);
				}
				$query['where'][] = 'a.status IN ('.implode(', ', $statuses).')';
			}
		} else {
			// if there are no status restrictions, default to LIVE assets only
			$query['where'][] = 'a.status  >= '.$db->quote(SQ_STATUS_LIVE);
		}

		// ASSET TYPE RESTRICTIONS
		if (!empty($search_info['asset_types'])) {
			$inherited_types = Array();
			$normal_types = Array();
			for (reset($search_info['asset_types']); NULL !== ($i = key($search_info['asset_types'])); next($search_info['asset_types'])) {
				if ($search_info['asset_types'][$i]) {
					$inherited_types[] = $db->quote($i);
				} else {
					$normal_types[] = $db->quote($i);
				}
			}

			$type_code_cond = Array();
			if (!empty($inherited_types)) {
				$type_code_cond[] = 'inhd_type_code IN ('.implode(', ', $inherited_types).')';
			}
			if (!empty($normal_types)) {
				$type_code_cond[] = 'type_code IN ('.implode(', ', $normal_types).')';
			}
			$type_code_cond = implode(' OR ', $type_code_cond);
			$query['where'][] = 'a.type_code IN (
									SELECT type_code
									FROM sq_ast_typ_inhd
									WHERE '.$type_code_cond.'
								)';
		}

		return $query;

	}//end constructBaseSearchQuery()


	/**
	* Combines asset scores according to the passed logic
	*
	* Returns a mapping from assetids to combined scores
	*
	* @param array	$asset_scores1		a mapping from assetids to scores
	* @param array	$asset_scores2		a mapping from assetids to scores
	* @param string	$logic				either 'AND' or 'OR'
	*
	* @return array
	* @access private
	*/
	function combineAssetScores($asset_scores1, $asset_scores2, $logic='AND', $word=null)
	{
		$result_scores = null;
		if (!is_array($asset_scores1) && !is_array($asset_scores2)) {
			$result_scores = Array();
		} else if (!is_array($asset_scores2)) {
			$result_scores = $asset_scores1;
		} else if (!is_array($asset_scores1)) {
			$result_scores = $asset_scores2;
		}

		if (!is_null($result_scores)) {
			if (is_array($result_scores) && !empty($result_scores) && !empty($word)) {
				foreach ($result_scores as $assetid => $data) {
					$this->_tmp['term_totals'][$assetid][$word] = $word;
				}
			}
			return $result_scores;
		}

		// find the intersection/union (depending on logic) of the assetids in field_asset_scores and results
		$assets1 = array_keys($asset_scores1);
		$assets2 = array_keys($asset_scores2);

		$out_asset_scores = $asset_scores1;

		if ($logic == 'AND') {
			$common_assets = array_intersect($assets1, $assets2);

			// get the assets that are to be removed in field_asset_scores
			$removed_assets = array_diff($assets1, $assets2);
			foreach ($removed_assets as $assetid) {
				unset($out_asset_scores[$assetid]);
				if (isset($this->_tmp['term_totals'][$assetid])) {
					unset($this->_tmp['term_totals'][$assetid]);
				}
			}

			foreach ($common_assets as $assetid) {
				if (isset($out_asset_scores[$assetid])) {
					$out_asset_scores[$assetid]['search_score'] = $out_asset_scores[$assetid]['search_score'] + $asset_scores2[$assetid]['search_score'];
				} else {
					$out_asset_scores[$assetid] = $asset_scores2[$assetid];
				}

				if (!empty($word)) {
					$this->_tmp['term_totals'][$assetid][$word] = $word;
				}

			}

		} else if ($logic == 'OR') {

			foreach ($asset_scores2 as $assetid => $data) {
				if (isset($out_asset_scores[$assetid])) {
					$out_asset_scores[$assetid]['search_score'] += $asset_scores2[$assetid]['search_score'];
				} else {
					$out_asset_scores[$assetid] = $asset_scores2[$assetid];
				}

				if (!empty($word)) {
					$this->_tmp['term_totals'][$assetid][$word] = $word;
				}

			}
		}
		return $out_asset_scores;

	}//end combineAssetScores()


	/**
	* Return an array of noise words
	*
	* @return array
	* @access public
	*/
	function getNoiseWords()
	{
		return $this->attr('noise_word_list');

	}//end getNoiseWords()


	/**
	* Return an array of white words
	*
	* @return array
	* @access public
	*/
	function getWhiteWords()
	{
		return $this->attr('white_word_list');

	}//end getWhiteWords()


	/**
	* Return true if word is in noise words
	*
	* @return boolean
	* @access public
	*/
	function isNoiseWord($word)
	{
		$words = $this->attr('noise_word_list');
		foreach ($words as $key => $value) {
			if (strcasecmp($key, $word) == 0) {
				return true;
			}
		}
		return false;

	}//end isNoiseWord()


	/**
	* Return true if word is in white words
	*
	* @return boolean
	* @access public
	*/
	function isWhiteWord($word)
	{
		$words = $this->attr('white_word_list');
		foreach ($words as $key => $value) {
			if (strcasecmp($key, $word) == 0) {
				return true;
			}
		}
		return false;

	}//end isWhiteWord()


	/**
	* Return the minimum indexable word lenght
	*
	* @return int
	* @access public
	*/
	function getMinWordLength()
	{
		return $this->attr('min_word_length');

	}//end getMinWordLength()


}//end class

?>
